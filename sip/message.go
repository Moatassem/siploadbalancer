/*
# Software Name : Newkah-SIP-Layer
# SPDX-FileCopyrightText: Copyright (c) 2025 - Orange Business - OINIS/Services/NSF

# Authors:
# - Moatassem Talaat <moatassem.talaat@orange.com>

---
*/

package sip

import (
	"bytes"
	"fmt"
	. "siploadbalancer/global"
	"strings"
)

type SipMessage struct {
	MsgType   MessageType
	StartLine *SipStartLine
	Headers   *SipHeaders
	Body      *MessageBody

	//all fields below are only set in incoming messages
	FromHeader string
	ToHeader   string
	PAIHeaders []string
	DivHeaders []string

	CallID    string
	FromTag   string
	ToTag     string
	ViaBranch string

	RCURI string
	RRURI string

	MaxFwds       int
	CSeqNum       uint32
	CSeqMethod    Method
	ContentLength uint16 //only set for incoming messages
}

func NewSipMessage() *SipMessage {
	return &SipMessage{}
}

// ==========================================================================

func (sipmsg *SipMessage) IsOutOfDialgoue() bool {
	return sipmsg.ToTag == ""
}

func (sipmsg *SipMessage) IsOptionSupportedOrRequired(o string) bool {
	hdr := sipmsg.Headers.ValueHeader(Require)
	if strings.Contains(hdr, o) {
		return true
	}
	hdr = sipmsg.Headers.ValueHeader(Supported)
	return strings.Contains(hdr, o)
}

func (sipmsg *SipMessage) IsOptionSupported(o string) bool {
	hdr := sipmsg.Headers.ValueHeader(Supported)
	hdr = ASCIIToLower(hdr)
	return hdr != "" && strings.Contains(hdr, o)
}

func (sipmsg *SipMessage) IsOptionRequired(o string) bool {
	hdr := sipmsg.Headers.ValueHeader(Require)
	hdr = ASCIIToLower(hdr)
	return hdr != "" && strings.Contains(hdr, o)
}

func (sipmsg *SipMessage) IsMethodAllowed(m Method) bool {
	hdr := sipmsg.Headers.ValueHeader(Allow)
	hdr = ASCIIToLower(hdr)
	return hdr != "" && strings.Contains(hdr, ASCIIToLower(m.String()))
}

func (sipmsg *SipMessage) IsResponse() bool {
	return sipmsg.MsgType == RESPONSE
}

func (sipmsg *SipMessage) IsRequest() bool {
	return sipmsg.MsgType == REQUEST
}

func (sipmsg *SipMessage) GetMethod() Method {
	return sipmsg.StartLine.Method
}

func (sipmsg *SipMessage) GetStatusCode() int {
	return sipmsg.StartLine.StatusCode
}

func (sipmsg *SipMessage) PrepareMessageBytes() {
	bb := bytes.Buffer{}
	var headers []string

	byteschan := make(chan []byte)

	go func(bc chan<- []byte) {
		bb2 := bytes.Buffer{}
		if sipmsg.Body.PartsBytes == nil {
			sipmsg.Headers.SetHeader(Content_Type, "")
			sipmsg.Headers.SetHeader(MIME_Version, "")
		} else {
			bdyparts := sipmsg.Body.PartsBytes
			if len(bdyparts) == 1 {
				k, v := FirstKeyValue(bdyparts)
				sipmsg.Headers.SetHeader(Content_Type, DicBodyContentType[k])
				sipmsg.Headers.SetHeader(MIME_Version, "")
				bb2.Write(v.Bytes)
			} else {
				sipmsg.Headers.SetHeader(Content_Type, fmt.Sprintf("multipart/mixed;boundary=%v", MultipartBoundary))
				sipmsg.Headers.SetHeader(MIME_Version, "1.0")
				for _, ct := range bdyparts {
					bb2.WriteString(fmt.Sprintf("--%v\r\n", MultipartBoundary))
					for _, h := range ct.Headers.GetHeaderNames() {
						_, values := ct.Headers.Values(h)
						for _, hv := range values {
							bb2.WriteString(fmt.Sprintf("%v: %v\r\n", HeaderCase(h), hv))
						}
					}
					bb2.WriteString("\r\n")
					bb2.Write(ct.Bytes)
				}
				bb2.WriteString(fmt.Sprintf("--%v--\r\n", MultipartBoundary))
			}
		}
		bc <- bb2.Bytes()
	}(byteschan)

	//startline
	if sipmsg.IsRequest() {
		sl := sipmsg.StartLine
		bb.WriteString(fmt.Sprintf("%v %v SIP/2.0\r\n", sl.Method.String(), sl.Ruri))
	} else {
		sl := sipmsg.StartLine
		bb.WriteString(fmt.Sprintf("SIP/2.0 %v %v\r\n", sl.StatusCode, sl.ReasonPhrase))
	}
	headers = sipmsg.Headers.GetHeaderNames()

	// var bodybytes []byte
	bodybytes := <-byteschan

	//body - build body type, length, multipart and related headers
	cntntlen := len(bodybytes)

	sipmsg.Headers.SetHeader(Content_Length, fmt.Sprintf("%v", cntntlen))

	//headers - build and write
	for _, h := range headers {
		_, values := sipmsg.Headers.Values(h)
		for _, hv := range values {
			if hv != "" {
				bb.WriteString(fmt.Sprintf("%v: %v\r\n", h, hv))
			}
		}
	}

	//P- headers build and write
	pHeaders := sipmsg.Headers.ValuesWithHeaderPrefix("P-")
	for h, hvs := range pHeaders {
		for _, hv := range hvs {
			if hv != "" {
				bb.WriteString(fmt.Sprintf("%v: %v\r\n", h, hv))
			}
		}
	}

	// write separator
	bb.WriteString("\r\n")

	// write body bytes
	bb.Write(bodybytes)

	//save generated bytes for retransmissions
	sipmsg.Body.MessageBytes = bb.Bytes()
}
